<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>
  class ArcMetadata extends XenState(XenElement) {
    static get observedAttributes() { return []; }
    constructor() {
      super();
      this._steps = [];
      this.store = document.createElement('arc-store');
    }
    createStep(plan, generations) {
      let step = this._createOriginatingStep(plan, generations);
      if (step) {
        ArcMetadata.log("createStep", step);
        this._steps.push(step);
        this._setState({steps: this._steps});
      }
      return this._state.steps;
    }
    _createOriginatingStep(plan, generations) {
      let origin = this._findFirstGeneration(plan, generations);
      if (origin) {
        // Really, we should only store the string and upon loading normalize it
        // again and create a new hash. But really, really we should probably
        // do something smarter than literal matching anyway...
        // Find all mapped views to be remembered.
        // Store as string, as we'll only use it to find exact matches later. (String is easier to compare)
        let mappedViews = plan.views
          .filter(v => (v.fate == "map") && (v.id.substr(0, 7) == "shared:"))
          .map(v => v.id)
          .sort()
          .toString()
          ;
        return {
          //recipe: origin.result.toString(),
          hash: origin.hash,
          mappedViews
        };
      }
    }
    _findFirstGeneration(plan, generations) {
      // Search generations in reverse order for the accepted plan
      let last_generation;
      generations.reverse().find(
        generation => last_generation = generation.find(member => member.result == plan)
      );
      if (!last_generation) {
        ArcMetadata.log("no originating generation found for", plan);
        return null;
      }
      // Walk derivation tree up to root. All paths will lead to the same root,
      // hence we can always take the first branch.
      let origin = last_generation;
      while (origin.derivation[0].parent) {
        origin = origin.derivation[0].parent;
      }
      return origin;
    }
  }
  ArcMetadata.module = document.currentImport;
  ArcMetadata.log = XenBase.logFactory('ArcMetadata', '#260e04');
  customElements.define('arc-metadata', ArcMetadata);
</script>
