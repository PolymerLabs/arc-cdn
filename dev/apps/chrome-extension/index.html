<!doctype html>
<html lang="en">
<head>

  <title>Arcs</title>
  <link rel="shortcut icon" href="favicon.ico">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

</head>
<body>

  <style>
    extension-app-shell {
      display: block;
      overflow: hidden;
      padding-top: 32px;
      padding-bottom: 64px;
      background-color: white;
    }

    extension-app-shell {
      min-width: 320px;
    }
    /* wider-than-mobile */
    @media (min-width: 500px) {
      extension-app-shell {
        box-sizing: border-box;
        margin: 0 auto;
        max-width: 700px;
      }
      extension-app-shell[expanded] {
        margin: 0;
        width: 414px;
        max-width: 414px;
      }
    }
  </style>

  <link rel="import" href="../../app-shell/app-shell.html">

  <extension-app-shell></extension-app-shell>

  <script>
    class ExtensionAppShell extends AppShell {

      /*
      _configure(obj) {
        let config = super._configure(obj);
        var appShell = this;

        let manifests = (new URL(document.location)).searchParams.getAll('manifest');
        config.additionalManifests = manifests.filter(elem => elem!=config.manifestPath);
        return config;
      }
      */

      async _fetchManifestList() {
        let manifests = await super._fetchManifestList();
        if (this._config.additionalManifests) {
          manifests.push(...this._config.additionalManifests);
        }
        return manifests;
      }

      /*
      async _loadAdditionalManifests(additionalManifests) {
        let futureManifests = additionalManifests.map(manifestPath => {
          return Arcs.Manifest.load(manifestPath, this._loader);
        });
        let manifests = await Promise.all(futureManifests);
        this.arc._context._imports.push(...manifests);
      }
      */

      async _start(config) {
        await super._start(config);
        var appshell = this;
        /*
        //// always take the browser arc public
        //StorageTools.saveProfileState(true);
        */

        window.addEventListener('message', event => {
          if (event.source != window || event.data.method != 'injectArcsData') {
            return;
          }
          console.log('do arcs!1!', event.data.entities);
          console.log(config);

          // reduce the deeply nested structure of url=>entities-of-many-types
          // to a flatter, combined form of type=>entities.
          let dataByType = Object.entries(event.data.entities).reduce( (accumulator, [key, value]) => {
            console.log('a', key, value);
            value.forEach(entry => {
              // XXX need to dedup in here as well
              let type = entry['@type'];
              accumulator[type] ? accumulator[type].push(entry) : accumulator[type] = [entry];
            });
            return accumulator;
          }, new Map());

          if (dataByType['text/x-arcs-manifest']) {
            config.additionalManifests = dataByType['text/x-arcs-manifest'].map(m => m.url);
          }

          // appshell._loadAdditionalManifests(config.additionalManifests).then(() => {
          appshell.reloadManifests().then(() => {
            // gather Arcs schemas for all known types
            var schemas = new Map(Object.entries(dataByType).map( ([fqTypeName, unused]) => {
              let shortTypeName = (fqTypeName.startsWith('http') && fqTypeName.includes('/'))
                  ? fqTypeName.split('/').slice(-1)[0] : fqTypeName;
              let schema = arc._context.findSchemaByName(shortTypeName);
              return [fqTypeName, schema];
            }));

            // the meat - create views, store entities in those.
            Object.entries(dataByType).forEach( ([fqTypeName, entities]) => {
              if (!schemas.has(fqTypeName) || !schemas.get(fqTypeName)) {
                console.log('Skipping unknown type '+fqTypeName);
                return;
              }

              const schema = schemas.get(fqTypeName);
              const shortTypeName = schema.name;
              const entityClass = schemas.get(fqTypeName).entityClass();

              // tag product views with shortlist
              let viewTag = shortTypeName=='Product' ? 'shortlist' : shortTypeName;

              var view = arc._context.newView(
                schema.type.viewOf(),
                'Browser/'+shortTypeName,
                arc.generateID()
                [viewTag]);

              // There are some fields that don't make sense in arcs, and
              // there are some values that aren't in the right format. Let's
              // fix all that up.
              let filteredEntities = entities.map(entity=>
                  new Map(Object.entries(entity)
                    .filter(([key, value]) => key!='@type')));

              debugger;
              filteredEntities.forEach(entity => view.store({id: arc.generateID(), rawData: entity}));
              console.log(view);
              // filteredEntities.forEach(entity => view.store(new entityClass(entity)));
            });

            // XXX or findSuggestions() again? or something else?
            self.dispatchEvent(new CustomEvent('manifests-change'));
          });
        }, false);

        // in case the message was sent & discarded, request sending of entities
        window.postMessage({method: 'pleaseInjectArcsData'}, '*');
      }

    }

    customElements.define('extension-app-shell', ExtensionAppShell);
  </script>

</body>
</html>
