<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>
  class RemoteFriendsProfileViews extends XenBase {
    static get observedAttributes() { return ['arc', 'friends','user']; }
    _getInitialState() {
      return {
        group: new WatchGroup(),
        db: db
      }
    }
    _update(props, state, lastProps) {
      if (props.arc && props.user && props.friends && props.friends !== lastProps.friends) {
        state.group.watches = this._watchFriends(state.db, state.group, props.arc, props.friends, props.user);
      }
    }
    _watchFriends(db, group, arc, friends, user) {
      friends = friends.map(friend => friend.rawData);
      // include `user` in friends, so we can access generic profile info this way
      // TODO(sjmiles): is this the right decision? this data is already available in another view
      friends.push({id: user.id});
      RemoteFriendsProfileViews.log('got raw FRIENDS', friends);
      return friends.map(friend => {
        return {
          node: db.child(`users/${friend.id}`),
          handler: snap => {
            group.add(this._watchFriendProfileViews(db, arc, friend, snap));
          }
        }
      });
    }
    _watchFriendProfileViews(db, arc, friend, snap) {
      // get user record
      let user = snap.val();
      RemoteFriendsProfileViews.log(`READING friend's user [${user.name}]`); // from`, String(snap.ref));
      // find keys for user's profile arcs
      return Arcs.utils.getUserProfileKeys(user).map(key => {
        //RemoteFriendsProfileViews.log(`watching friend's [${user.name}] profile views`); // from`, String(snap.ref));
        return {
          node: db.child(`arcs/${key}/views`),
          handler: snap => {
            RemoteFriendsProfileViews.log(`READING friend's [${user.name}] profile views`); // from`, String(snap.ref));
            let views = snap.val();
            if (views) {
              this._processFriendProfileViews(arc, friend, views);
            }
          }
        }
      });
    }
    _processFriendProfileViews(arc, friend, views) {
      //RemoteFriendsProfileViews.log(`friend's profile views`, friend, views);
      Object.keys(views).forEach(key => {
        let {values, metadata: {name, type, tags}} = views[key];
        let arcsType = Arcs.utils.typeFromMetaType(type).setViewOf();
        let tagString = (tags && tags.length ? `${tags.sort().join('_').replace(/#/g, '')}` : '');
        let id = `FRIENDS_PROFILE_${tagString}`;
        //RemoteFriendsProfileViews.log(`processing view [${id}]`);
        if (values) {
          let view = this._requireView(arc, id, arcsType, id, [`#friends_${tagString}`]);
          if (!Array.isArray(values)) {
            values = [values];
          }
          let data = values.map(v => {
            v.rawData.owner = friend.id;
            return {
              id: v.id, //arc.generateID(),
              rawData: v.rawData
            };
          });
          Arcs.utils.addViewData(view, data);
          RemoteFriendsProfileViews.log(`merged friend's profile view [${id}]`); //, id, view, data);
        }
      });
    }
    _requireView(arc, id, type, name, tags) {
      return arc.context.findViewById(id) || arc.context.newView(type, name, id, tags);
    }
  }
  RemoteFriendsProfileViews.module = document.currentImport;
  RemoteFriendsProfileViews.log = XenBase.logFactory('RemoteFriendsPV', '#805acb');
  customElements.define('remote-friends-profiles-views', RemoteFriendsProfileViews);
</script>
